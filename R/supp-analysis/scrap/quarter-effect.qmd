---
title: "Test spatially varying quarter effect"
author: "Max Lindmark"
date: "`r format(Sys.time(), '%d %B, %Y')`"
format: 
  html:
    embed-resources: true
    fig-width: 8
    fig-asp: 0.618
knitr: 
  opts_chunk:
    fig.align: center
editor: source
execute: 
  echo: true
  eval: true
  cache: true
---

## Load packages & source functions

```{r load libraries}
#| cache: false
#| message: false
#| warning: false
#| output: false
#| code-fold: true

# Load libraries, install if needed
library(tidyverse)
library(tidylog)
library(RCurl)
library(viridis)
library(devtools)
library(patchwork)
library(future)

# with_libpaths(new = "/Users/maxlindmark/Dropbox/Max work/R/sdmTMB-zeta-intercept/",
#               install_github("pbs-assess/sdmTMB", ref = "zeta-intercept"))

library(sdmTMB, lib.loc = "/Users/maxlindmark/Dropbox/Max work/R/sdmTMB-zeta-intercept")

# https://github.com/pbs-assess/sdmTMB/tree/zeta-intercept

# Source code for map plots
sf::sf_use_s2(FALSE)
source_url("https://raw.githubusercontent.com/maxlindmark/pred-prey-overlap/main/R/functions/map-plot.R")

# Set path:
home <- here::here()
```

```{r}
# To load entire cache in interactive r session, do: 
# qwraps2::lazyload_cache_dir(path = paste0(home, "/R/supp-analysis/quarter-effect_cache/html"))
```

## Read and summarize data
- likely not scaling correctly here but anyway its same across all models so it doesn't matter i think (now I square the scaled variable, and do not scale the variables squared by the centered variables (which I anyway forgot here). This means the squared variable (squared on the scaled original variable), doesn't have an sd of 1 but like 1.5 = 1.7. Is that ok?)

```{r read biomass data}
#| cache: false
#| message: false
#| warning: false
#| code-fold: true

# Read data
d <- readr::read_csv("https://raw.githubusercontent.com/maxlindmark/pred-prey-overlap/main/data/clean/catch_clean.csv") |> 
  rename(X = x, Y = y) |> 
  drop_na(depth, oxy, sal, temp) |> 
  mutate(depth_ct = depth - mean(depth),
         depth_sq = depth_ct^2,
         depth_sc = depth_ct / sd(depth),
         temp_ct = temp - mean(temp),
         temp_sq = temp_ct^2,
         temp_sc = temp_ct / sd(temp),
         oxy_ct = oxy - mean(oxy),
         oxy_sc = oxy_ct / sd(oxy),
         sal_ct = sal - mean(sal),
         sal_sc = sal_ct / sd(sal),
         year_f = as.factor(year),
         substrate_f = as.factor(substrate)) |> 
  filter(cod_sad < quantile(cod_sad, prob = 0.99),
         cod_pel < quantile(cod_pel, prob = 0.99)) |> 
  mutate(quarter2 = ifelse(quarter == 2, 1, quarter),
         quarter2 = ifelse(quarter == 3, 4, quarter2),
         quarter_f = as.factor(quarter2))
```

## Read and scale the prediction grid

```{r}
#| cache: false
#| message: false
#| warning: false
#| code-fold: true

home <- here::here()
pred_grid <- bind_rows(read_csv(paste0(home, "/data/clean/pred_grid_(1_2).csv")),
                       read_csv(paste0(home, "/data/clean/pred_grid_(2_2).csv")))

# Scale with respect to data!
pred_grid <- pred_grid |> 
  drop_na(oxy, temp, sal, substrate) |> # TODO: move to prediction grid
  mutate(X = X,
         Y = Y,
         depth_ct = depth - mean(d$depth),
         depth_sc = depth_ct / sd(d$depth),
         depth_sq = depth_ct^2,
         
         temp_ct = temp - mean(d$temp),
         temp_sq = temp_ct^2,
         temp_sc = temp_ct / sd(d$temp),
         
         oxy_sc = (oxy - mean(d$oxy)) / sd(d$oxy),
         sal_sc = (sal - mean(d$sal)) / sd(d$sal),
         year_f = as.factor(year),
         quarter_f = as.factor(quarter),
         substrate_f = as.factor(substrate))
```

```{r}
# Load models
# qwraps2::lazyload_cache_dir(path = "R/supp-analysis/quarter-effect_cache/html")
```

## Create meshes

```{r}
#| cache: false
# mesh <- make_mesh(d,
#                   xy_cols = c("X", "Y"),
#                   n_knots = 200,
#                   type = "kmeans",
#                   seed = 42)

mesh <- make_mesh(d,
                  xy_cols = c("X", "Y"),
                  cutoff = 10)

ggplot() + inlabru::gg(mesh$mesh) + coord_fixed() +
  geom_point(aes(X, Y), data = d, alpha = 0.2, size = 0.5)
```

## Fit models

Depth as fixed effects

```{r fit mcod_sad fd}
mcod_sad_fd <- sdmTMB(cod_sad ~ 0 + year_f + quarter_f + depth_sc + depth_sq + temp_sc + temp_sq + oxy_sc + sal_sc,
                      data = d,
                      mesh = mesh,
                      family = tweedie(link = "log"),
                      spatiotemporal = "AR1",
                      spatial = "on",
                      time = "year")

sanity(mcod_sad_fd)
summary(mcod_sad_fd)
tidy(mcod_sad_fd, effects = "ran_pars", conf.int = TRUE)
```

Depth as time varying

```{r fit mcod_sad tw}
mcod_sad_tw <- sdmTMB(cod_sad ~ 0 + year_f + quarter_f + temp_sc + temp_sq + oxy_sc + sal_sc,
                      data = d,
                      time_varying = ~0 + depth_sc + depth_sq,
                      mesh = mesh,
                      family = tweedie(link = "log"),
                      spatiotemporal = "AR1",
                      spatial = "on",
                      time = "year")

sanity(mcod_sad_tw)
summary(mcod_sad_tw)
tidy(mcod_sad_tw, effects = "ran_pars", conf.int = TRUE)
```

Better sanity results with a time-varying effect! Now proceed with that model to see how quarter should be implemented

```{r}
#| message: false
#| warning: false
nd <- expand.grid(
  depth = seq(min(d$depth) + 0.2,
              max(d$depth) - 0.2,
    length.out = 50
  ),
  year = unique(d$year) # all years
) |> 
  mutate(year_f = as.factor(year),
         quarter_f = as.factor(1),
         temp_sc = mean(d$temp_sc),
         temp_sq = mean(d$temp_sq),
         oxy_sc = mean(d$oxy_sc),
         sal_sc = mean(d$sal_sc),
         depth_ct = depth - mean(d$depth),
         depth_sc = depth_ct / sd(d$depth),
         depth_sq = depth_ct^2)

p <- predict(mcod_sad_tw, newdata = nd, se_fit = TRUE, re_form = NA)
```

```{r}
ggplot(p, aes(depth, exp(est),
  #ymin = exp(est - 1.96 * est_se),
  #ymax = exp(est + 1.96 * est_se),
  group = as.factor(year)
)) +
  geom_line(aes(colour = year)) +
  #geom_ribbon(aes(fill = year), alpha = 0.1) +
  scale_colour_viridis_c() +
  scale_fill_viridis_c() +
  #scale_x_continuous(labels = function(x) round(exp(x * pcod$depth_sd[1] + pcod$depth_mean[1]))) +
  coord_cartesian(expand = F) +
  labs(x = "Depth (m)", y = "Biomass density (kg/km2)")
```

"Main" model with quarter as a factor and a single spatial field

```{r fit mcod_sad}
mcod_sad <- sdmTMB(cod_sad ~ 0 + year_f + quarter_f + temp_sc + temp_sq + oxy_sc + sal_sc,
                   data = d,
                   mesh = mesh,
                   time_varying = ~0 + depth_sc + depth_sq,
                   family = tweedie(link = "log"),
                   spatiotemporal = "AR1",
                   spatial = "on",
                   time = "year")

sanity(mcod_sad)
summary(mcod_sad)
tidy(mcod_sad, effects = "ran_pars", conf.int = TRUE)
```

Quarter as a spatially varying coefficient

```{r fit mcod_sad_sv}
mcod_sad_sv <- sdmTMB(cod_sad ~ 0 + year_f + quarter_f + temp_sc + temp_sq + oxy_sc + sal_sc,
                      data = d,
                      mesh = mesh,
                      time_varying = ~0 + depth_sc + depth_sq,
                      family = tweedie(link = "log"),
                      spatiotemporal = "AR1",
                      spatial = "off",
                      spatial_varying = ~0 + quarter_f,
                      time = "year")

sanity(mcod_sad_sv)
summary(mcod_sad_sv)
tidy(mcod_sad_sv, effects = "ran_pars", conf.int = TRUE)
```

## Predict and plot random fields

```{r predict mcod_sad_sv}
pred_sv <- predict(mcod_sad_sv, newdata = pred_grid)
pred <- predict(mcod_sad, newdata = pred_grid)
```

```{r plot predictions}
p1 <- pred_sv |>
  filter(year == 1999) |> 
  pivot_longer(c("zeta_s_quarter_f1", "zeta_s_quarter_f4")) |> 
  ggplot(aes(X, Y, fill = value)) +
  geom_raster() +
  coord_fixed() + 
  facet_wrap(~name) +
  scale_fill_viridis() + 
  ggtitle("Spatially varying quarter")

p2 <- pred |>
  filter(year == 1999) |> 
  ggplot(aes(X, Y, fill = omega_s)) +
  geom_raster() +
  coord_fixed() + 
  scale_fill_viridis() + 
  ggtitle("Single spatial random field")

p1 + p2 + plot_layout(heights = c(1, 1))
```

## Compare models with cross validation

```{r cv1}
clust <- sample(1:5, size = nrow(d), replace = T)

mcod_sad_cv <- sdmTMB_cv(cod_sad ~ 0 + year_f + quarter_f + s(depth_sc) + temp_sc + temp_sq + oxy_sc + sal_sc,
                         data = d,
                         mesh = mesh,
                         family = tweedie(link = "log"),
                         spatiotemporal = "AR1",
                         spatial = "on",
                         time = "year",
                         fold_ids = clust,
                         parallel = TRUE,
                         use_initial_fit = TRUE,
                         k_folds = length(unique(clust)))

```

```{r cv2}
mcod_sad_sv_cv <- sdmTMB_cv(cod_sad ~ 0 + year_f + quarter_f + s(depth_sc) + temp_sc + temp_sq + oxy_sc + sal_sc,
                            data = d,
                            mesh = mesh,
                            family = tweedie(link = "log"),
                            spatiotemporal = "AR1",
                            spatial = "off",
                            spatial_varying = ~0 + quarter_f,
                            time = "year",
                            fold_ids = clust,
                            parallel = TRUE,
                            use_initial_fit = TRUE,
                            k_folds = length(unique(clust)))

```

```{r}
# Compare log-likelihoods -- higher is better!
mcod_sad_sv_cv$sum_loglik
mcod_sad_cv$sum_loglik

# Compare ELPD -- higher is better!
mcod_sad_sv_cv$elpd
mcod_sad_cv$elpd

# AIC?
AIC(mcod_sad_sv, mcod_sad)
```
